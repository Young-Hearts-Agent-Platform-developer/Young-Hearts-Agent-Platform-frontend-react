# MOCK 用户未生效原因研究报告

## 版本记录

| 日期 | 版本 | 修改内容 | 修改原因 |
|---|---|---|---|
| 2026-01-13 | v1.0 | 初始分析 | 用户反馈 MOCK 用户未生效 |
| 2026-01-13 | v1.1 | 增补mock结构兼容性分析与修复建议 | 代码实现变更与问题定位 |

## 研究问题
参考目前的效果图，为什么没能成功启用 MOCK 用户？

## 发现摘要
- 个人中心页面通过 `useUser` 获取用户信息，但 `user` 默认为 null，未显示 MOCK 用户。
- 用户信息由 `UserContext` 提供，实际数据依赖 `getCurrentUser` API。
- `getCurrentUser` 在开发环境下直接返回 `MOCK_USER`，但未包装为 `{ user: MOCK_USER }`，导致 `UserContext` 解析失败。
- 代码无其他 mock 配置入口，环境变量已为 development，mock 分支能被命中。
- 个人中心页面渲染逻辑未变，依赖 `user`，实际始终为 null。

## 相关文件清单
|文件路径|作用说明|关键行号|
|---|---|---|
|src/api/auth.js|mock用户对象与API实现|L1-L40|
|src/store/UserContext.jsx|用户上下文与数据拉取|L1-L66|
|src/store/useUser.js|用户上下文消费钩子|L1-L14|
|src/pages/my/index.jsx|个人中心页面渲染|L1-L40|

## 当前实现分析
- `UserContext.jsx` 通过 `getCurrentUser` 拉取用户数据，期望返回结构为 `{ user: ... }`，实际 mock 返回为 `MOCK_USER`，导致 `setUser(res.user || null)` 结果为 null。
- `useUser.js` 返回 `UserContext`，若无则返回默认值（user: null）。
- `my/index.jsx` 通过 `useUser` 获取 `user`，渲染昵称与角色，未登录时显示“未登录”。
- 代码无其他 mock 配置入口，环境变量已为 development，mock 分支能被命中。

### mock结构与UserContext兼容性分析
- 期望结构：`getCurrentUser` 返回 `{ user: {...} }`，即后端接口风格。
- 实际mock：开发环境下直接返回 `MOCK_USER`，未加壳，导致 `res.user` 为 undefined。
- 结果：`setUser(res.user || null)` 恒为 null，mock 失效。

### 核心流程
```
[页面渲染] → [useUser] → [UserContext] → [fetchUser] → [getCurrentUser API] → [开发环境下返回MOCK_USER] → [setUser(res.user || null)] → [user=null时显示未登录]
```

### 关键代码片段
- `src/api/auth.js` L21-L29
  ```js
  export async function getCurrentUser() {
    if (import.meta.env.MODE === 'development') {
      return MOCK_USER;
    }
    // ...真实API请求
  }
  ```
- `src/store/UserContext.jsx` L13-L16
  ```js
  try {
    const res = await getCurrentUser();
    setUser(res.user || null);
  } catch {
    setUser(null);
  }
  ```

## 架构洞察
- mock分支能被命中，但mock数据结构与上下文消费不兼容。
- 只需调整mock返回结构即可修复。

## 潜在风险和边缘情况
- 若后续mock结构与真实API不一致，易导致前端消费异常。
- 需统一mock与真实接口的返回格式。

## 开放问题
- 是否所有API都需mock时保持结构一致？
- 是否考虑在UserContext层做兼容性兜底？

## 修复建议
- 将 `getCurrentUser` 的mock分支返回结构由 `MOCK_USER` 改为 `{ user: MOCK_USER }`，即：
  ```js
  if (import.meta.env.MODE === 'development') {
    return { user: MOCK_USER };
  }
  ```
- 或在 `UserContext` 的 `setUser` 处兼容mock结构（如 `setUser(res.user || res)`），但推荐前者，保持mock与真实接口一致。

## 参考资料
- [src/api/auth.js](src/api/auth.js#L1-L40)
- [src/store/UserContext.jsx](src/store/UserContext.jsx#L1-L66)
- [src/store/useUser.js](src/store/useUser.js#L1-L14)
- [src/pages/my/index.jsx](src/pages/my/index.jsx#L1-L40)


# Gemini 3 Pro 的解决

**具体原因：**
1.  **Context 无法穿透到父级**：原代码中 `UserProvider` 被放置在 `HomeLayout` 组件内。而在 `MyPage` 中，我们先调用了 `useUser()`，然后才渲染 `HomeLayout`。由于 `MyPage` 是 `HomeLayout` 的父组件（或者说调用者），它处于 `UserProvider` 的**外部**，因此无法获取到 `HomeLayout` 内部提供的 Context 数据，只能拿到默认初始值（null）。
2.  **Context 导出缺失**：UserContext.jsx 文件中没有导出 `UserContext` 对象，导致 `useUser` hook 可能无法正确引用 Context 上下文。

**修复方案：**
1.  **提升 Provider 层级**：将 `UserProvider` 移动到全局入口 App.jsx 中，包裹整个路由系统。这样应用内所有页面和组件（包括 `MyPage`）都在 Provider 内部，可以随时访问用户状态。
2.  **清理重复 Provider**：从 `HomeLayout` 中移除了局部的 `UserProvider`，避免不必要的嵌套和状态重置。
3.  **修复导出**：在 UserContext.jsx 中显式导出了 `UserContext`。

**已执行的修改：**

1.  **修改 UserContext.jsx**：添加了 `export { UserContext };`。
2.  **修改 App.jsx**：引入并添加了 `<UserProvider>` 包裹。
3.  **修改 HomeLayout.jsx**：移除了 `<UserProvider>`。

现在刷新页面，个人中心应该能正确显示“心青年开发者”的用户信息了。

Made changes.