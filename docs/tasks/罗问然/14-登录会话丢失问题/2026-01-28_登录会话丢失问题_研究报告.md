# 登录后 Session 丢失问题研究报告

## 版本记录

| 日期 | 版本 | 修改内容 | 修改原因 |
|---|---|---|---|
| 2026-01-28 | v1.0 | 初始研究 | 用户反馈登录后后端报错“未在 Cookie 或 Header 中找到 session_id” |

## 研究问题

登录成功后，后续请求（如获取用户信息、咨询会话等）后端返回错误：`未在 Cookie 或 Header 中找到 session_id`。

## 发现摘要

1.  **前端实现**：前端使用了标准的 `fetch` API，并在 `src/api/auth.js` 中为 `login` 和其他请求设置了 `credentials: 'include'`。这意味着前端期望浏览器自动处理 Cookie 的接收（Set-Cookie）和发送。
2.  **后端要求**：报错信息表明后端可以通过 Cookie 或 Header 接收 `session_id`。
3.  **潜在原因**：
    *   **跨域问题 (CORS)**：如果前后端域名/端口不一致（常见于开发环境），且后端未正确配置 CORS（需 `Access-Control-Allow-Credentials: true` 且 `Access-Control-Allow-Origin` 不能为 `*`），浏览器将拒绝保存 `Set-Cookie`，导致后续请求没有 Cookie。
    *   **Cookie 策略**：浏览器的 `SameSite` 和 `Secure` 属性可能限制了 Cookie 的发送（特别是在非 HTTPS 环境下）。
    *   **Header 缺失**：虽然后端支持 Header 传参，但前端当前并未实现手动从登录响应中提取 token 并添加到 Header 的逻辑。

## 相关文件清单

| 文件路径 | 作用说明 | 关键行号 |
|---|---|---|
| src/api/auth.js | 封装登录和用户信息 API，配置了 credentials | L100-L120 |
| src/config/apiConfig.js | API 基础路径配置 | L1-L5 |
| openapi.json | 后端接口定义，暗示了 UserLogin 结构 | L769 |

## 当前实现分析

### 1. 登录请求
在 `src/api/auth.js` 中，登录请求如下：

```javascript
export async function login({ username, password }) {
  try {
    const res = await fetch(`${API_BASE}/login`, {
      method: 'POST',
      credentials: 'include', // 关键：请求此时会携带 Cookie，并允许响应设置 Cookie
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ username, password })
    });
    // ...
  }
  // ...
}
```

### 2. 后续请求
获取当前用户信息的请求也配置了 `credentials: 'include'`：

```javascript
export async function getCurrentUser() {
  // ...
  const res = await fetch(`${API_BASE}/me`, {
    credentials: 'include',
  });
  // ...
}
```

### 3. 会话 ID 歧义
代码中存在两类 `session_id`：
*   **Chat Session ID**：用于咨询业务（Consultation），在 `src/pages/consultation/chat.jsx` 中通过 URL 参数获取。
*   **Auth Session ID**：用于用户鉴权，通常存储在 Cookie 中（Key 可能为 `session_id`）。
用户遇到的报错指代的是后者（Auth Session ID）。

## 架构洞察与解决方案建议

### 方案 A：修复 Cookie 跨域问题（推荐）
如果坚持使用 Cookie（更安全，防 XSS），需要确保开发环境和生产环境的 CORS 配置正确。
1.  **开发环境**：确保 Vite 代理配置正确，或者后端显式允许前端源（http://localhost:5173）并开启 Credentials。
2.  **浏览器检查**：开发者在 Chrome DevTools -> Application -> Cookies 中查看 `/login` 请求后是否成功写入了 Cookie。如果 `Login` 响应头有 `Set-Cookie` 但 Application tab 里没有，说明被浏览器拦截了（通常会有黄色警告 icon）。

### 方案 B：改用 Header 传递 Token（备选）
如果后端在 `/login` 的 JSON 响应体中也返回了 `session_id` 或 `token` 字段，前端可以手动存储它。
1.  修改 `login` 方法，将返回的 Token 存入 `localStorage`。
2.  创建一个 API 请求拦截器（或封装 fetch），在所有请求的 Header 中自动附加 `session_id: <token>` 或 `Authorization: Bearer <token>`。

## 潜在风险

- **安全风险**：如果切换到 `localStorage` 存储 Token，会增加 XSS 攻击的风险（虽然在本项目初期可能不是首要矛盾）。
- **开发效率**：Cookie 调试在跨域环境下比较麻烦，可能干扰开发进度。

## 下一步行动建议

1.  **验证环节**：请开发者打开浏览器控制台 Network 面板，检查 `/login` 响应头中的 `Set-Cookie` 字段内容，以及 Console 面板是否有 CORS 或 Cookie 相关的警告。
2.  **代码调整**：如果确认是跨域问题且难以后端调整，建议临时采用方案 B（前提是后端 Login 接口返回了 Token 字符串）。
