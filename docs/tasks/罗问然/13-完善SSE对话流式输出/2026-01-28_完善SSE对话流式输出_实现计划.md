# [完善SSE对话流式输出] 实现计划

## 版本记录

| 日期 | 版本 | 修改内容 | 修改原因 |
|---|---|---|---|
| 2026-01-28 | v1.0 | 初始计划 | 基于 V1 研究报告及用户提供的协议规范 |
| 2026-01-28 | v1.1 | Phase 1/2协议与参数适配 | message事件data为JSON格式，onMessage(content) |

## 关联研究
docs/tasks/罗问然/13-完善SSE对话流式输出/2026-01-28_完善SSE对话流式输出_研究报告.md

## 功能概述
重构 `consult` 模块的 `chatSSE` 方法，废弃原有的非标准按行解析逻辑，转而实现符合标准 Server-Sent Events (SSE) 规范的流式解析器。
本次重构将严格遵循明确定义的 `event` 与 `data` 协议，不再兼容旧格式，并增强对分包截断（Chunking）的处理。
特别说明：`event: message` 的 `data` 字段为 JSON 字符串（如 `{"content":"你好\n世界"}`），前端需解析后提取 content 字段。

## 协议规范

根据用户指示，前端将解析以下标准 SSE 格式：

| 场景 | Event Type | Data 格式 | 示例 | 处理逻辑 |
|---|---|---|---|---|
| AI 内容片段 | `message` (或省略) | JSON String | `{"content":"..."}` | 解析后提取 content，拼接至对话内容 |
| 会话主题 | `topic` | JSON String | `data: {"topic": "打招呼"}` | 解析后更新会话标题 |
| 错误信息 | `error` | JSON String | `data: {"detail": "超时"}` | 解析后抛出错误或显示提示 |
| 结束信号 | `done` | JSON String | `data: [DONE]` | 关闭连接 |

> **注意**：不再支持旧版的 `[TOPIC]`, `[ERROR]` 行首标记。

## Phase 1: 核心解析器重构

### 目标
在 `src/api/consult.js` 中重写流式处理逻辑，引入 buffer 机制以正确处理网络分包，并依据 SSE 协议解析 `event` 和 `data` 字段。
特别要求：仅支持新格式 message 事件，`data` 必须为 JSON 字符串，需解析后提取 content 字段。

### 修改文件清单

|文件路径|修改类型|说明|
|---|---|---|
|src/api/consult.js|Modify|重构 `chatSSE` 函数内部解析逻辑|

### 具体变更

#### 1. src/api/consult.js

- **移除**：旧的 `split(/(\r?\n)/)` 简单分割逻辑。
- **新增**：`parseStream` 内部辅助函数或直接在 `chatSSE` 中实现 buffer 状态机。
- **逻辑**：
    - 维护 `buffer` 变量。
    - 循环读取 reader，将 chunk 解码追加到 buffer。
    - 查找双换行 `\n\n` 作为事件分隔符（标准 SSE 分隔符）。
    - 对每个事件块进行按行解析，提取 `event` 和 `data`。
    - 根据 `event` 类型分发：
      - `message`: 尝试 `JSON.parse(data)`，提取 `content`，调用 `onMessage(content)`。如解析失败，`console.warn` 输出原始 data 及错误。
      - `topic`: 解析 JSON，调用 `onMessage(topicText, { isTopic: true })`。
      - `error`: 解析 JSON，调用 `onMessage(errorText, { isError: true })` 或抛出异常。
      - `done`: 终止循环。

**代码构思 (伪代码)**:

```javascript
// buffer 处理
let buffer = '';
while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  buffer += decoder.decode(value, { stream: true });
  
  let parts = buffer.split('\n\n'); // SSE 消息以双换行分隔
  buffer = parts.pop(); // 保留最后一个不完整的部分
  
  for (const part of parts) {
    if (!part.trim()) continue;
    
    let eventType = 'message';
    let data = '';
    
    // 解析行
    const lines = part.split('\n');
    for (const line of lines) {
      if (line.startsWith('event:')) {
        eventType = line.substring(6).trim();
      } else if (line.startsWith('data:')) {
        data = line.substring(5).trim(); // 注意：标准 SSE 允许多个 data 行，这里简化处理或需拼接
      }
    }
    
    // 分发处理
    if (eventType === 'message') {
      try {
        const obj = JSON.parse(data);
        if (typeof obj.content === 'string') {
          onMessage(obj.content);
        } else {
          console.warn('[SSE] message data.content 非字符串', data);
        }
      } catch (e) {
        console.warn('[SSE] message data 解析失败', data, e);
      }
    } else {
      handleEvent(eventType, data, onMessage);
    }
  }
}
```

### 验证标准
- [ ] 针对标准 SSE 格式的 Mock 数据流，能够正确解析出文本。
- [ ] 能够正确处理跨 Chunk 的断行（例如 `data: {"content":"你"}` 和 `data: {"content":"好"}`）。
- [ ] 收到 `event: topic` 时，能正确提取 JSON 中的 topic 并触发标题更新。
- [ ] 收到 message 事件 data 解析失败时，能在控制台输出警告。

## Phase 2: 调用方适配 (按需)

### 目标
确保 `src/pages/consultation/chat.jsx` 能够正确响应 Phase 1 传递出的数据结构（message 事件直接传 content 字符串）。

### 修改文件清单

|文件路径|修改类型|说明|
|---|---|---|
|src/pages/consultation/chat.jsx|Modify|适配 `onMessage` 回调参数（如果 Phase 1 改变了传参结构）|

### 具体变更

#### 1. Adapter 策略 (推荐在 Phase 1 内部解决)
message 事件直接传递 content 字符串：`onMessage(content)`。
topic、error 事件保持原有 meta 结构。
如 chat.jsx 依赖 meta 参数，需适配为直接接收 content。

### 验证标准
- [ ] 聊天界面能正常逐字显示 AI 回复。
- [ ] 会话标题能根据后端返回自动更新。
- [ ] 出现 Error 事件时界面有相应反馈。

## 交付清单
1. 更新后的 `src/api/consult.js`。
2. (可选) 更新后的 `src/pages/consultation/chat.jsx`。
