# 通过 context 实现用户身份控制 研究报告

## 版本记录

| 日期 | 版本 | 修改内容 | 修改原因 |
|---|---|---|---|
| 2026-01-13 | v1.0 | 初始设计 | 无 |
| 2026-01-13 | v1.1 | 重构设计 | 根据用户反馈增强权限粒度(Card级)与安全性(HttpOnly Cookie) |
| 2026-01-13 | v1.2 | 简化Header | Header组件调整为纯静态展示，移除所有身份操作 |

## 研究问题

如何在 React 前端项目中通过 context 实现用户身份的全局管理与访问控制，满足“Card组件级权限”、“仅个人中心展示”以及“HttpOnly Cookie 优先安全策略”的特定需求。

## 发现摘要

- **状态管理**：使用 `UserContext` 作为全局单一数据源，维护 `user` 对象及 `isAuthenticated` 状态。
- **存储与安全**：鉴权凭证（Token）完全由后端通过 `HttpOnly Cookie` 写入，前端无法读取，防止 XSS 窃取。前端应用初始化时通过 API (`/api/auth/me`) 验证会话并获取用户信息与权限列表。
- **组件联动**：`Card` 组件将接入 Context，根据当前用户权限动态决定是完整渲染、隐藏还是显示占位符。
- **展示策略**：全局 Context 虽持有用户信息，但仅在 `pages/my` 路径下的相关组件中进行视觉渲染。`Header` 组件调整为**纯静态展示**，不订阅 UserContext，不随登录态变化，也不提供登录入口。

## 相关文件清单

|文件路径|类型|作用说明|
|---|---|---|
|`src/store/UserContext.jsx`|新增|用户状态管理核心，提供 `useUser` hook 和权限校验方法|
|`src/api/auth.js`|新增|鉴权接口封装，处理登录、登出、获取当前用户 (Session Check)|
|`src/components/Card/index.jsx`|现有|基础 UI 组件，需增强为“权限感知”组件|
|`src/pages/my/index.jsx`|新增|个人中心主页，用户信息的各种展示区域|
|`src/layouts/HomeLayout.jsx`|现有|需在此处或更高层级包裹 `UserProvider`|

## 建议实现方案

### 核心设计理念

放弃前端存储 Token (localStorage/Cookie) 的方案，改用 **Session-based Authentication (via HttpOnly Cookies)** 模式。

1. **登录**：前端 POST 账号密码 -> 后端验证成功 -> 后端 Set-Cookie (HttpOnly) -> 返回成功响应（不含 Token）。
2. **初始化**：App 挂载 -> `UserProvider` `useEffect` 调用 `/api/auth/me` -> 浏览器自动携带 Cookie -> 后端验证 -> 返回 User Profile。
3. **权限控制**：Context 提供 `checkPermission(resource, action)` 函数。
4. **登出**：前端调用 API -> 后端清除 Cookie -> 前端清理 Context。

### 核心流程图

```
[App 初始化] → [UserProvider Mount] → [调用 /api/auth/me] → [后端验证 HttpOnly Cookie] → [成功: 存入 User & Permissions / 失败: User=null]

[Card 组件渲染] → [useUserContext 获取权限] → [有权限: 正常渲染 / 无权限: 隐藏或占位]

[个人中心页面] → [读取 User 对象] → [展示头像/详情]
[Header 组件] → [静态渲染] → [不涉及任何用户状态]
```

### 关键代码片段设计

#### 1. `src/store/UserContext.jsx` - 身份与权限核心

```jsx
import React, { createContext, useState, useContext, useEffect } from 'react';
import Cookies from 'js-cookie'; 
import { getCurrentUser, login as apiLogin, logout as apiLogout } from '../api/auth';

const UserContext = createContext(null);

export const UserProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // 初始化检查登录态
  useEffect(() => {
    const initAuth = async () => {
      try {
        const userData = await getCurrentUser(); // 自动带上 Cookie
        setUser(userData);
      } catch (error) {
        // Session无效或网络错误
        setUser(null);
      } finally {
        setLoading(false);
      }
    };
    initAuth();
  }, []);

  const login = async (credentials) => {
    const userData = await apiLogin(credentials);
    setUser(userData);
    return userData;
  };

  const logout = async () => {
    try {
      await apiLogout(); 
    } finally {
      setUser(null);
      // 清理可能存在的客户端辅助 Cookie (如非敏感偏好)
      Cookies.remove('user_pref'); 
    }
  };

  const checkPermission = (requiredRole) => {
    if (!user) return false;
    // 简单示例：检查 roles 数组
    if (!requiredRole) return true; 
    return user.roles?.includes(requiredRole);
  };

  return (
    <UserContext.Provider value={{ user, loading, login, logout, checkPermission, isAuthenticated: !!user }}>
      {!loading && children} 
    </UserContext.Provider>
  );
};

export const useUser = () => useContext(UserContext);
```

#### 2. `src/components/Card/index.jsx` - 权限感知组件

```jsx
import React from 'react';
import { useUser } from '../../store/UserContext'; // 假设路径正确

const Card = ({ title, children, requiredRole, ...props }) => {
  // 注意：useUser 需要在 Provider 内部使用，如果 Card 用在 Provider 外需处理异常
  // 这里假设 Card 总是被包裹在 App 的 Provider 中
  const { checkPermission } = useUser();
  
  // 权限控制逻辑
  if (requiredRole && !checkPermission(requiredRole)) {
    return null; // 或者返回 <div className="no-permission">无权限查看</div>
  }

  return (
    <div className="card-container" {...props}>
      {title && <div className="card-header">{title}</div>}
      <div className="card-body">{children}</div>
    </div>
  );
};
```

## 架构洞察与风险

### 洞察
1. **安全性优先**：通过 HttpOnly Cookie 彻底规避了 XSS 攻击获取 Token 的风险，符合企业级安全标准。
2. **UI 与 数据解耦**：明确划分了数据的持有者 (Context) 和展示者 (Only MyPage)，避免了用户信息满天飞导致的数据泄露风险。
3. **权限下沉**：将权限逻辑下沉到基础组件 (`Card`)，使得页面开发人员只需关注业务逻辑，无需重复编写 `if (user.role === 'admin')` 这样的样板代码。

### 潜在风险
1. **CSRF 风险**：Cookie 鉴权天然面临 CSRF 威胁，必须确保后端配置了 `SameSite: Strict` 或 `Lax`，并校验 Referer/Origin。
2. **初始化白屏**：`UserProvider`在 `useEffect` 完成前可能会阻塞渲染（`!loading && children`），如果 API 响应慢，用户会看到长时间白屏。建议添加全局 Loading Spinner。

## 开放问题 (已涵盖)

- **权限粒度**：已确认需精细到 `Card` 组件，通过 props `requiredRole` 实现。
- **展示范围**：已明确限制在个人中心。`Header` 组件已移除所有动态逻辑，确保完全静态。
- **Cookie 策略**：已确认采用 `HttpOnly` 为主，`js-cookie` 为辅的混合安全模式。

## 参考资料

- [React 官方 Context 文档](https://react.dev/reference/react/createContext)
- [MDN HttpOnly Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)
